var fs = require('fs');
var path = require('path');
var handlebars = require('handlebars');
var sane = require('sane');
var GulpProject = require('./gulp-project');

var defaultTemplate = handlebars.compile(fs.readFileSync(
      path.resolve(__dirname, 'views', 'error.handlebars')).toString());

function errorResponse(response, log, template) {
  response.status(500);
  if(template) {
    response.render(template, log);
  } else {
    response.send(defaultTemplate(log));
  }
}

/**
 * Fire up a toasty Griddle.
 *
 * Executes a gulp build in the provided src path (assuming gulp and it's
 * dependencies exist).  Also optionally watch the specified directory
 * for changes.
 *
 * @param   {string}    src                The directory in which to execute a gulp build.
 * @param   {string}    [watch=undefined]  Optional directory to watch for changes and execute
 *                                          builds as they occur.
 * @param   {string}    template           Path to a template to use for errors instead of the built in one.
 *
 * @returns {Function}  Griddle middleware handler.  Provides publich unwatch() method for releasing
 *                      any associated watchers.
 */
module.exports = function(src, watch, template) {
  var gp = new GulpProject(path.resolve(src));

  // Always kick off an initial build
  gp.build();

  // If we're supposed to, kick off a build whenever anything
  // changes.
  if(watch && fs.existsSync(watch)) {
    // The ignore initial flag prevents chokidar from throwing "add" events
    // for existing files / directories
    var watcher = sane(watch);
    watcher.on('all', gp.build.bind(gp));
  }

  var griddle = function(request, response, next) {
    switch(gp.status()) {
      case GulpProject.Status.LAST_BUILD_FAILED:
        errorResponse(response, gp.log(), template);
        break;
      case GulpProject.Status.BUILDING:
        gp.buildCompleted().then(next, function() {
          response.status(500);
          errorResponse(response, gp.log(), template);
        });
        break;
      default:
        next();
    }
  };

  /**
   * Stops any watchers associated with the Griddle.
   *
   * @returns {undefined}
   */
  griddle.unwatch = function() {
    if(watcher) {
      watcher.close();
    }
  };

  return griddle;
};
